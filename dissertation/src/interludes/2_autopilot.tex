\chapter*{A Turn to Tools}

The tools that we used for the "Mice Can Learn Phonetic Categories" paper were hopelessly broken, and so I went in search of better ones. To my surprise, none could be found --- there were pieces and parts, but no generalizable experimental software for behavioral experiments. 

We had been using a piece of software that required an entire desktop computer per experimental chamber, was initially not version controlled and relied on copying and pasting code on a flashdrive between each computer, and had no documentation of any kind. Without any frame of reference for research software, I couldn't tell if the bugs we were experiencing were "normal." One particularly memorable one that convinced me we could do better was when Lucas let me know that suddenly there was a 5-10 second lag in between every phase of every trial, and it turned out that any time there was an error (which there always were), the program was booting an email server and using some hardcoded credentials to email them it to the author --- but when the author changed their password, the server would try to send until it timed out, blocking the program. I was convinced we should write a new tool. I was warned against this many times, one of which being a well-known visiting PI telling me that "you'll either publish no papers, or be on everybody's paper, but almost certainly the former." I have this personality flaw where I would rather spend the time making something that works than spending several years struggling with something terrible, and did it anyway.

It seemed like it should be possible to run each experiment from a lower powered computer, but all of the tools that I could find were using state machines on microcontrollers like Arduinos which were still dependent on some host computer to control them. I thought that it might be easier to run the entire software on the board, and so turned to the Raspberry Pi. I had started grad school with maybe a few dozen hours of programming experience and had so far experienced it mostly as grinding against an impenetrable wall, but after seeing how Santiago had written \href{https://github.com/sjara/taskontrol}{taskontrol} in Python realized that it was possible for code to make sense. Most of what I had been struggling with was a byproduct of MATLAB being godforsaken language that encourages bad programming practices, so I abandoned it and started exploring the wider world of languages and programming practices. I adopted some of the ideas from Ratrix: each of the components of the experiment like tasks, stimuli, etc. should be separable building blocks, spent two weeks reading through the Python \href{https://docs.python.org/3/tutorial/index.html}{tutorial} and language references, and using taskontrol for inspiration for code structure got to work on what would become Autopilot.

The realization that autonomous networked agents and objects should be the core of the system came relatively quickly, influenced by the manifesto-like \href{https://zguide.zeromq.org/}{zeromq guide} --- though not quickly enough to avoid my inexperience with programming baking in some incompatible design decisions that we're still working out roughly five years later. This was at a time when I was still spending late nights in the lab misappropriating the one computer with a DVD drive to rip movies for a private torrent tracker (sorry Mike) and watching the traffic in the swarm\sidenote{one of my oldest computer habits, it is a hypnotic window into what the internet could be like.}, and so I started to wonder if that same idea of many linked computers working together could be used for experiments.  The more I leaned into that idea the more powerful it seemed, and I began to imagine a swarm of raspis being able to run everything in the lab. We haven't quite made it there yet, but nothing has convinced me that dream can't be real.